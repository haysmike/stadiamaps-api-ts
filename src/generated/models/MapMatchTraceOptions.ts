/* tslint:disable */
/* eslint-disable */
/**
 * Stadia Maps Geospatial APIs
 * The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications. All endpoints are versioned individually to allow for granular upgrades. We follow the [Semantic Versioning scheme](https://semver.org/).
 *
 * The version of the OpenAPI document: 5.0.0
 * Contact: support@stadiamaps.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
/**
 * 
 * @export
 * @interface MapMatchTraceOptions
 */
export interface MapMatchTraceOptions {
    /**
     * The search radius, in meters, when trying to match each trace point.
     * @type {number}
     * @memberof MapMatchTraceOptions
     */
    searchRadius?: number;
    /**
     * The accuracy of the GPS, in meters.
     * @type {number}
     * @memberof MapMatchTraceOptions
     */
    gpsAccuracy?: number;
    /**
     * The breaking distance, in meters, between trace points.
     * @type {number}
     * @memberof MapMatchTraceOptions
     */
    breakageDistance?: number;
    /**
     * The interpolation distance, in meters, beyond which trace points are merged together.
     * @type {number}
     * @memberof MapMatchTraceOptions
     */
    interpolationDistance?: number;
    /**
     * Penalizes turns from one road segment to next. For a pedestrian trace, you may see a back-and-forth motion along the streets of your path with the default settings. Try increasing the turn penalty factor to 500 to reduce jitter in the output. Note that if GPS accuracy is already good, increasing this above the default will usually negatively affect the quality of map matching.
     * @type {number}
     * @memberof MapMatchTraceOptions
     */
    turnPenaltyFactor?: number;
}

/**
 * Check if a given object implements the MapMatchTraceOptions interface.
 */
export function instanceOfMapMatchTraceOptions(value: object): boolean {
    let isInstance = true;

    return isInstance;
}

export function MapMatchTraceOptionsFromJSON(json: any): MapMatchTraceOptions {
    return MapMatchTraceOptionsFromJSONTyped(json, false);
}

export function MapMatchTraceOptionsFromJSONTyped(json: any, ignoreDiscriminator: boolean): MapMatchTraceOptions {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'searchRadius': !exists(json, 'search_radius') ? undefined : json['search_radius'],
        'gpsAccuracy': !exists(json, 'gps_accuracy') ? undefined : json['gps_accuracy'],
        'breakageDistance': !exists(json, 'breakage_distance') ? undefined : json['breakage_distance'],
        'interpolationDistance': !exists(json, 'interpolation_distance') ? undefined : json['interpolation_distance'],
        'turnPenaltyFactor': !exists(json, 'turn_penalty_factor') ? undefined : json['turn_penalty_factor'],
    };
}

export function MapMatchTraceOptionsToJSON(value?: MapMatchTraceOptions | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'search_radius': value.searchRadius,
        'gps_accuracy': value.gpsAccuracy,
        'breakage_distance': value.breakageDistance,
        'interpolation_distance': value.interpolationDistance,
        'turn_penalty_factor': value.turnPenaltyFactor,
    };
}

