/* tslint:disable */
/* eslint-disable */
/**
 * Stadia Maps Geospatial APIs
 * The Stadia Maps Geospatial APIs provide you with the data you need to build awesome applications. All endpoints are versioned individually to allow for granular upgrades. We follow the [Semantic Versioning scheme](https://semver.org/).
 *
 * The version of the OpenAPI document: 4.1.0
 * Contact: support@stadiamaps.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { Coordinate } from './Coordinate';
import {
    CoordinateFromJSON,
    CoordinateFromJSONTyped,
    CoordinateToJSON,
} from './Coordinate';
import type { CostingOptions } from './CostingOptions';
import {
    CostingOptionsFromJSON,
    CostingOptionsFromJSONTyped,
    CostingOptionsToJSON,
} from './CostingOptions';
import type { MatrixCostingModel } from './MatrixCostingModel';
import {
    MatrixCostingModelFromJSON,
    MatrixCostingModelFromJSONTyped,
    MatrixCostingModelToJSON,
} from './MatrixCostingModel';
import type { ValhallaLanguages } from './ValhallaLanguages';
import {
    ValhallaLanguagesFromJSON,
    ValhallaLanguagesFromJSONTyped,
    ValhallaLanguagesToJSON,
} from './ValhallaLanguages';

/**
 * 
 * @export
 * @interface OptimizedRouteRequest
 */
export interface OptimizedRouteRequest {
    /**
     * 
     * @type {string}
     * @memberof OptimizedRouteRequest
     */
    units?: OptimizedRouteRequestUnitsEnum;
    /**
     * 
     * @type {ValhallaLanguages}
     * @memberof OptimizedRouteRequest
     */
    language?: ValhallaLanguages;
    /**
     * The level of directional narrative to include. Locations and times will always be returned, but narrative generation verbosity can be controlled with this parameter.
     * @type {string}
     * @memberof OptimizedRouteRequest
     */
    directionsType?: OptimizedRouteRequestDirectionsTypeEnum;
    /**
     * An identifier to disambiguate requests (echoed by the server).
     * @type {string}
     * @memberof OptimizedRouteRequest
     */
    id?: string;
    /**
     * The list of locations. The first and last are assumed to be the start and end points, and all intermediate points are locations that you want to visit along the way.
     * @type {Array<Coordinate>}
     * @memberof OptimizedRouteRequest
     */
    locations: Array<Coordinate>;
    /**
     * 
     * @type {MatrixCostingModel}
     * @memberof OptimizedRouteRequest
     */
    costing: MatrixCostingModel;
    /**
     * 
     * @type {CostingOptions}
     * @memberof OptimizedRouteRequest
     */
    costingOptions?: CostingOptions;
}


/**
 * @export
 */
export const OptimizedRouteRequestUnitsEnum = {
    Km: 'km',
    Mi: 'mi'
} as const;
export type OptimizedRouteRequestUnitsEnum = typeof OptimizedRouteRequestUnitsEnum[keyof typeof OptimizedRouteRequestUnitsEnum];

/**
 * @export
 */
export const OptimizedRouteRequestDirectionsTypeEnum = {
    None: 'none',
    Maneuvers: 'maneuvers',
    Instructions: 'instructions'
} as const;
export type OptimizedRouteRequestDirectionsTypeEnum = typeof OptimizedRouteRequestDirectionsTypeEnum[keyof typeof OptimizedRouteRequestDirectionsTypeEnum];


/**
 * Check if a given object implements the OptimizedRouteRequest interface.
 */
export function instanceOfOptimizedRouteRequest(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "locations" in value;
    isInstance = isInstance && "costing" in value;

    return isInstance;
}

export function OptimizedRouteRequestFromJSON(json: any): OptimizedRouteRequest {
    return OptimizedRouteRequestFromJSONTyped(json, false);
}

export function OptimizedRouteRequestFromJSONTyped(json: any, ignoreDiscriminator: boolean): OptimizedRouteRequest {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'units': !exists(json, 'units') ? undefined : json['units'],
        'language': !exists(json, 'language') ? undefined : ValhallaLanguagesFromJSON(json['language']),
        'directionsType': !exists(json, 'directions_type') ? undefined : json['directions_type'],
        'id': !exists(json, 'id') ? undefined : json['id'],
        'locations': ((json['locations'] as Array<any>).map(CoordinateFromJSON)),
        'costing': MatrixCostingModelFromJSON(json['costing']),
        'costingOptions': !exists(json, 'costing_options') ? undefined : CostingOptionsFromJSON(json['costing_options']),
    };
}

export function OptimizedRouteRequestToJSON(value?: OptimizedRouteRequest | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'units': value.units,
        'language': ValhallaLanguagesToJSON(value.language),
        'directions_type': value.directionsType,
        'id': value.id,
        'locations': ((value.locations as Array<any>).map(CoordinateToJSON)),
        'costing': MatrixCostingModelToJSON(value.costing),
        'costing_options': CostingOptionsToJSON(value.costingOptions),
    };
}

